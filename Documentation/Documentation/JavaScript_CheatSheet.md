# JavaScript Шпаргалка

## 1. Undefined vs Null

### Undefined - Коли щось "не визначено"

`undefined` - це примітивний тип в JavaScript, який автоматично присвоюється змінним, які були оголошені, але не ініціалізовані. Це стандартне значення за замовчуванням для змінних в JavaScript.

Коли змінна оголошена через `var`, `let` або `const`, але не має присвоєного значення, JavaScript автоматично присвоює їй `undefined`. Це відбувається під час процесу hoisting та ініціалізації змінних.

Функції, які не повертають значення явно, автоматично повертають `undefined`. Це стандартна поведінка JavaScript - якщо функція не має return statement або return statement не вказує значення, результат виклику функції буде `undefined`.

При спробі доступу до неіснуючої властивості об'єкта також повертається `undefined`. Це безпечна поведінка JavaScript, яка дозволяє уникнути помилок при роботі з об'єктами.

```javascript
let a; // undefined
console.log(a); // undefined

function test() {
  // нічого не повертає
}
console.log(test()); // undefined

const obj = {};
console.log(obj.nonExistent); // undefined
```

### Null - Явно присвоєне "порожнє" значення

`null` - це спеціальне значення в JavaScript, яке представляє навмисну відсутність будь-якого об'єкта. На відміну від `undefined`, `null` завжди присвоюється явно програмістом.

`null` використовується для позначення того, що змінна навмисно не містить жодного значення або посилання на об'єкт. Це важливий концепт в JavaScript для роботи з об'єктами та їх властивостями.

Важливо розуміти семантичну різницю: `undefined` означає, що значення не було присвоєно, а `null` означає, що значення було навмисно встановлено як "відсутнє".

```javascript
let b = null; // явно присвоєно null
console.log(b); // null

// Перевірка
console.log(typeof undefined); // "undefined"
console.log(typeof null); // "object" (це баг в JS)
console.log(null === undefined); // false
console.log(null == undefined); // true (нестроге порівняння)
```

## 2. Event Loop - Як JavaScript керує завданнями

### Принцип роботи - Архітектура асинхронного виконання

JavaScript використовує однопотокову модель виконання з Event Loop для обробки асинхронних операцій. Це означає, що JavaScript може виконувати тільки один блок коду одночасно, але Event Loop дозволяє ефективно обробляти асинхронні завдання.

Event Loop - це механізм, який постійно перевіряє чергу завдань та виконує їх у відповідному порядку. Він забезпечує неблокуюче виконання коду, дозволяючи браузеру залишатися відзивним під час обробки складних операцій.

JavaScript має три основні типи черг: стек викликів (call stack), черга мікротасків (microtask queue) та черга макротасків (macrotask queue). Event Loop керує пріоритетами виконання між цими чергами.

```javascript
console.log("1"); // синхронний код

setTimeout(() => {
  console.log("2"); // макротаск
}, 0);

Promise.resolve().then(() => {
  console.log("3"); // мікротаск
});

console.log("4"); // синхронний код

// Результат: 1, 4, 3, 2
```

### Пріоритети виконання - Порядок обробки завдань

JavaScript має чітко визначений порядок виконання завдань, який забезпечує передбачувану поведінку асинхронного коду.

1. **Синхронний код** - виконується одразу в порядку появи
2. **Мікротаски** (Promise, queueMicrotask) - виконуються після завершення синхронного коду
3. **Макротаски** (setTimeout, setInterval, setImmediate) - виконуються після всіх мікротасків

Цей порядок гарантує, що важливі завдання (мікротаски) виконуються перед менш важливими (макротаски), що критично для правильної роботи Promise та інших асинхронних конструкцій.

## 3. Замикання (Closures) - Функції з пам'яттю

### Визначення - Механізм збереження контексту

Замикання - це функція, яка має доступ до змінних зовнішньої області видимості навіть після того, як зовнішня функція завершила виконання. Це фундаментальний концепт JavaScript, який дозволяє створювати функції з "пам'яттю" про своє оточення.

Коли функція створюється всередині іншої функції, внутрішня функція "захоплює" змінні зовнішньої функції. Ці змінні зберігаються в замиканні і залишаються доступними навіть після завершення виконання зовнішньої функції.

Замикання створюються автоматично в JavaScript - кожна функція, створена всередині іншої функції, автоматично стає замиканням. Це дозволяє створювати приватні змінні та інкапсуляцію в JavaScript.

```javascript
function outerFunction(x) {
  return function innerFunction(y) {
    return x + y; // x зберігається в замиканні
  };
}

const addFive = outerFunction(5);
console.log(addFive(3)); // 8

// Практичний приклад
function createCounter() {
  let count = 0;
  return {
    increment: () => ++count,
    decrement: () => --count,
    getCount: () => count,
  };
}

const counter = createCounter();
console.log(counter.increment()); // 1
console.log(counter.increment()); // 2
console.log(counter.getCount()); // 2
```

У цьому прикладі `createCounter` створює замикання зі змінною `count`. Функції `increment`, `decrement` і `getCount` мають доступ до цієї змінної навіть після завершення виконання `createCounter`. Це дозволяє створювати приватний стан, недоступний ззовні.

## 4. Прототип (Prototype) - Спадкування в JavaScript

### Прототипне наслідування - Механізм делегування

JavaScript використовує прототипне наслідування - механізм, при якому об'єкти можуть наслідувати властивості та методи від інших об'єктів через ланцюжок прототипів.

Кожен об'єкт в JavaScript має внутрішню властивість `[[Prototype]]`, яка вказує на інший об'єкт або `null`. Коли ви намагаєтесь отримати доступ до властивості об'єкта, JavaScript спочатку шукає її в самому об'єкті, а якщо не знаходить - шукає в прототипі об'єкта, потім в прототипі прототипа, і так далі по ланцюжку.

Цей механізм дозволяє створювати ієрархії об'єктів та перевикористовувати код без дублювання. Прототипне наслідування є основою об'єктно-орієнтованого програмування в JavaScript.

```javascript
// Конструктор
function Person(name) {
  this.name = name;
}

// Методи в прототипі
Person.prototype.sayHello = function () {
  return `Hello, I'm ${this.name}`;
};

const person = new Person("John");
console.log(person.sayHello()); // "Hello, I'm John"

// Наслідування
function Employee(name, position) {
  Person.call(this, name);
  this.position = position;
}

Employee.prototype = Object.create(Person.prototype);
Employee.prototype.constructor = Employee;

Employee.prototype.getInfo = function () {
  return `${this.name} - ${this.position}`;
};

const employee = new Employee("Jane", "Developer");
console.log(employee.sayHello()); // "Hello, I'm Jane"
console.log(employee.getInfo()); // "Jane - Developer"
```

У цьому прикладі `Employee` наслідує від `Person` через прототипне наслідування. Це означає, що кожен екземпляр `Employee` має доступ до всіх властивостей та методів `Person`, а також може мати свої власні.

### Сучасний підхід (ES6 Classes) - Синтаксичний цукор

ES6 ввів синтаксис класів, який є синтаксичним цукром над прототипним наслідуванням. Класи роблять код більш читабельним та зрозумілим для розробників, звиклих до класичного ООП.

```javascript
class Person {
  constructor(name) {
    this.name = name;
  }

  sayHello() {
    return `Hello, I'm ${this.name}`;
  }
}

class Employee extends Person {
  constructor(name, position) {
    super(name);
    this.position = position;
  }

  getInfo() {
    return `${this.name} - ${this.position}`;
  }
}
```

Ключове слово `extends` створює прототипне наслідування між класами. `super()` викликає конструктор батьківського класу та передає необхідні параметри.

## 5. Arrow Functions vs Explicit Call, Bind, Apply - Керування контекстом

### Arrow Functions - Функції-стрілки з особливим поведінкою

Уявіть собі, що у вас є два типи офіціантів: звичайний офіціант і офіціант-робот. Звичайний офіціант знає, хто його начальник (контекст `this`), а офіціант-робот завжди працює за однаковими правилами, незалежно від ситуації.

Arrow functions - це як офіціант-робот. Вони не мають власного `this`, а "запам'ятовують" `this` з того місця, де були створені. Це як фотографія, яка зберігає момент часу з усіма деталями.

Коли ви використовуєте arrow function всередині об'єкта, вона не "знає" про цей об'єкт. Це може бути корисно в деяких випадках, але може призвести до неочікуваної поведінки.

```javascript
const obj = {
  name: "Object",
  regularMethod: function () {
    console.log(this.name);
  },
  arrowMethod: () => {
    console.log(this.name); // undefined (this не прив'язаний)
  },
};

obj.regularMethod(); // "Object"
obj.arrowMethod(); // undefined
```

У цьому прикладі `regularMethod` знає, що він належить до об'єкта `obj`, тому може отримати доступ до `this.name`. Але `arrowMethod` не має власного `this`, тому намагається використати `this` з глобальної області видимості, де `name` не визначено.

### Call, Apply, Bind - Три способи "передати" контекст

Уявіть собі, що у вас є спеціаліст з певною експертизою, і ви хочете, щоб він працював у різних місцях. У вас є три способи це зробити:

1. **Call** - як тимчасово "відправити" спеціаліста на інше робоче місце
2. **Apply** - те ж саме, але з іншим способом передачі інформації
3. **Bind** - як "найняти" спеціаліста на постійну роботу в новому місці

```javascript
const person = {
  name: "John",
  greet: function (greeting, punctuation) {
    return `${greeting}, ${this.name}${punctuation}`;
  },
};

const anotherPerson = { name: "Jane" };

// Call - передає аргументи окремо
console.log(person.greet.call(anotherPerson, "Hello", "!")); // "Hello, Jane!"

// Apply - передає аргументи як масив
console.log(person.greet.apply(anotherPerson, ["Hi", "?"])); // "Hi, Jane?"

// Bind - створює нову функцію з прив'язаним контекстом
const boundGreet = person.greet.bind(anotherPerson);
console.log(boundGreet("Hey", ".")); // "Hey, Jane."
```

У цьому прикладі ми "використовуємо" метод `greet` від `person`, але "заставляємо" його працювати з даними `anotherPerson`. Це як сказати: "Використай цей метод, але працюй з іншими даними".

## 6. Promise/Async Await - Обіцянки та асинхронність

### Promise - Обіцянка виконати завдання

Уявіть собі, що ви замовляєте їжу в ресторані. Офіціант дає вам чек (Promise) і каже: "Я обіцяю принести вашу їжу". Цей чек може мати три стани: "чекаю" (pending), "готово" (fulfilled) або "помилка" (rejected).

Promise - це об'єкт, який представляє результат асинхронної операції. Це як квиток на концерт - він гарантує, що ви отримаєте результат, але не одразу.

Коли ви створюєте Promise, ви "обіцяєте" виконати якусь роботу. Ця робота може бути успішною (resolve) або невдалою (reject). Це як пообіцяти другу прийти на зустріч - або ви прийдете, або скажете, що не можете.

```javascript
// Створення Promise
const myPromise = new Promise((resolve, reject) => {
  const random = Math.random();
  if (random > 0.5) {
    resolve("Success!");
  } else {
    reject("Error!");
  }
});

// Використання
myPromise
  .then((result) => console.log(result))
  .catch((error) => console.error(error));

// Promise.all - всі Promise мають виконатися
const promises = [Promise.resolve(1), Promise.resolve(2), Promise.resolve(3)];

Promise.all(promises).then((results) => console.log(results)); // [1, 2, 3]

// Promise.race - перший виконаний Promise
Promise.race([
  new Promise((resolve) => setTimeout(() => resolve("Fast"), 100)),
  new Promise((resolve) => setTimeout(() => resolve("Slow"), 1000)),
]).then((result) => console.log(result)); // "Fast"
```

`Promise.all` - це як чекати, поки всі друзі зберуться перед початком вечірки. `Promise.race` - це як гонка, де перемагає той, хто прийде першим.

### Async/Await - Синтаксичний цукор для Promise

Async/await - це спосіб писати асинхронний код так, ніби він синхронний. Це як читати книгу замість дивитися фільм - ви можете зупинитися в будь-який момент і подумати.

Ключове слово `async` перед функцією означає, що ця функція завжди повертає Promise. Ключове слово `await` означає "почекай, поки цей Promise виконається, а потім продовжуй".

Це робить код більш читабельним і зрозумілим. Замість ланцюжка `.then()` ви можете писати код так, ніби кожна операція виконується послідовно.

```javascript
async function fetchUserData() {
  try {
    const response = await fetch("https://api.example.com/user");
    const user = await response.json();
    return user;
  } catch (error) {
    console.error("Error fetching user:", error);
    throw error;
  }
}

// Паралельне виконання
async function fetchMultipleUsers() {
  const [user1, user2] = await Promise.all([
    fetchUserData(1),
    fetchUserData(2),
  ]);
  return [user1, user2];
}
```

У цьому прикладі `await fetch()` чекає, поки запит до сервера завершиться, а потім `await response.json()` чекає, поки відповідь буде перетворена в об'єкт. Це як сказати: "Спочатку отримай дані, а потім оброби їх".

## 7. JavaScript Types - Різні види даних

### Примітивні типи - Базові будівельні блоки

Уявіть собі, що ви будуєте будинок. У вас є різні типи матеріалів: цегла, дерево, метал, скло. В JavaScript також є різні типи даних - примітивні типи, які є базовими будівельними блоками.

Примітивні типи - це прості значення, які не є об'єктами. Вони "незмінні" (immutable), що означає, що ви не можете змінити їх, а тільки створити нові. Це як числа - ви не можете змінити число 5, але можете створити число 6.

```javascript
// Number
const num = 42;
const float = 3.14;
const infinity = Infinity;
const nan = NaN;

// String
const str = "Hello";
const template = `Hello ${name}`;

// Boolean
const bool = true;

// Undefined
let undef;

// Null
const nullValue = null;

// Symbol (ES6)
const symbol = Symbol("description");

// BigInt (ES2020)
const bigInt = 9007199254740991n;
```

Кожен тип має своє призначення. `Number` - для чисел, `String` - для тексту, `Boolean` - для так/ні, `Symbol` - для унікальних ідентифікаторів, `BigInt` - для дуже великих чисел.

### Об'єктні типи - Складні структури даних

Об'єктні типи - це складніші структури, які можуть містити кілька значень. Це як складний механізм, який складається з багатьох частин.

```javascript
// Object
const obj = { key: "value" };

// Array
const arr = [1, 2, 3];

// Function
function func() {}

// Date
const date = new Date();

// RegExp
const regex = /pattern/;
```

Об'єкти можуть містити властивості та методи. Масиви - це спеціальний тип об'єктів для зберігання списків. Функції - це об'єкти, які можна викликати. `Date` - для роботи з датами, `RegExp` - для роботи з регулярними виразами.

### Перевірка типів - Як дізнатися, що це за тип

Уявіть собі, що у вас є коробка з подарунком, і ви хочете дізнатися, що всередині. Ви можете подивитися на етикетку або відкрити коробку. В JavaScript є кілька способів перевірити тип даних.

```javascript
typeof 42; // "number"
typeof "hello"; // "string"
typeof true; // "boolean"
typeof undefined; // "undefined"
typeof null; // "object" (баг)
typeof {}; // "object"
typeof []; // "object"
typeof function () {}; // "function"

// Кращий спосіб перевірки масивів
Array.isArray([]); // true
Array.isArray({}); // false
```

`typeof` - це як подивитися на етикетку коробки. Але є особливості: `typeof null` повертає `"object"` - це відомий баг в JavaScript, який залишився для сумісності зі старим кодом.

Для більш точної перевірки використовують спеціальні методи, як `Array.isArray()` для масивів або `instanceof` для об'єктів.

## 8. Hoisting - Підняття змінних та функцій

### Підняття змінних - Коли JavaScript "піднімає" оголошення

Уявіть собі, що ви читаєте книгу з кінця. Хоча ви ще не дочитали до початку, ви вже знаєте, що в книзі є певні персонажі. В JavaScript щось подібне відбувається з оголошеннями змінних та функцій - вони "піднімаються" на початок своєї області видимості.

Hoisting - це механізм JavaScript, при якому оголошення змінних та функцій "переміщуються" на початок їх області видимості під час компіляції. Це не означає, що код фізично переміщується, але JavaScript "знає" про ці оголошення з самого початку.

Важливо розуміти різницю між оголошенням та ініціалізацією. Оголошення "піднімається", але присвоєння значення залишається на своєму місці.

```javascript
console.log(x); // undefined (не помилка)
var x = 5;

// Еквівалентно:
var x;
console.log(x); // undefined
x = 5;
```

У цьому прикладі JavaScript "знає" про змінну `x` з самого початку, тому `console.log(x)` не викликає помилку, але значення ще не присвоєно, тому виводиться `undefined`.

### Підняття функцій - Функції "піднімаються" повністю

Функції піднімаються по-різному залежно від способу їх оголошення. Function declaration (оголошення функції) піднімається повністю, включаючи тіло функції. Function expression (функціональний вираз) піднімається тільки як змінна.

```javascript
sayHello(); // "Hello!" (працює)

function sayHello() {
  console.log("Hello!");
}

// Function expression не піднімається
sayGoodbye(); // TypeError: sayGoodbye is not a function

const sayGoodbye = function () {
  console.log("Goodbye!");
};
```

У першому випадку функція `sayHello` "піднімається" повністю, тому її можна викликати до оголошення. У другому випадку `sayGoodbye` піднімається тільки як змінна зі значенням `undefined`, тому виклик призводить до помилки.

## 9. Var, Const, Let - Різні способи оголошення змінних

### Var (Function-scoped) - Старий спосіб з особливостями

Уявіть собі, що у вас є стара система організації документів, де всі документи зберігаються в одному великому шухляді. Якщо ви покладете документ з назвою "важливо" в шухляду, а потім покладете інший документ з такою ж назвою, старий буде замінений.

`var` - це старий спосіб оголошення змінних в JavaScript. Змінні, оголошені через `var`, мають function-scope (область видимості функції), що означає, що вони доступні в межах всієї функції, де були оголошені.

```javascript
function example() {
  var x = 1;
  if (true) {
    var x = 2; // перезаписує x
  }
  console.log(x); // 2
}
```

У цьому прикладі змінна `x` оголошена в функції `example`, тому вона доступна в межах всієї функції. Коли ми оголошуємо `var x = 2` в блоці `if`, ми перезаписуємо значення змінної `x`, а не створюємо нову змінну.

### Let (Block-scoped) - Сучасний спосіб з блочною областю видимості

Уявіть собі, що у вас є нова система організації документів з окремими папками для кожного проекту. Якщо ви покладете документ "важливо" в папку "Проект А", а потім покладете документ з такою ж назвою в папку "Проект Б", це будуть різні документи.

`let` - це сучасний спосіб оголошення змінних, введений в ES6. Змінні, оголошені через `let`, мають block-scope (блочну область видимості), що означає, що вони доступні тільки в межах блоку, де були оголошені.

```javascript
function example() {
  let x = 1;
  if (true) {
    let x = 2; // нова змінна
  }
  console.log(x); // 1
}

// Temporal Dead Zone
console.log(y); // ReferenceError
let y = 5;
```

У цьому прикладі змінна `x` в блоці `if` - це нова змінна, яка не впливає на змінну `x` в функції. Temporal Dead Zone (TDZ) - це період між початком області видимості та оголошенням змінної, коли змінна ще не доступна.

### Const (Block-scoped, immutable reference) - Константи

Уявіть собі, що у вас є скринька з скарбами, яку ви закрили на замок. Ви не можете замінити скриньку на іншу, але можете додавати або забирати скарби всередині.

`const` - це спосіб оголошення констант. Змінні, оголошені через `const`, не можуть бути переприсвоєні, але їх властивості (якщо це об'єкт) можна змінювати.

```javascript
const PI = 3.14;
// PI = 3.15; // TypeError

const obj = { name: "John" };
obj.name = "Jane"; // OK (змінюємо властивість, не посилання)
// obj = {}; // TypeError
```

У цьому прикладі `PI` не може бути змінено, оскільки це константа. Але властивість `name` об'єкта `obj` може бути змінена, оскільки ми змінюємо вміст об'єкта, а не саме посилання на об'єкт.

## 10. Оператори - Інструменти для роботи з даними

### Арифметичні оператори - Математичні дії

Уявіть собі, що у вас є калькулятор з різними кнопками для математичних операцій. В JavaScript також є оператори для виконання математичних дій.

```javascript
+ - * / % ** ++ --
```

Ці оператори дозволяють виконувати додавання, віднімання, множення, ділення, знаходження залишку від ділення, піднесення до степеня, інкремент та декремент.

### Оператори порівняння - Порівняння значень

Уявіть собі, що ви порівнюєте два предмети: який важчий, який більший, чи вони однакові. Оператори порівняння дозволяють порівнювати значення в JavaScript.

```javascript
== === != !== < > <= >=
```

Важливо розуміти різницю між `==` (нестроге порівняння) та `===` (строге порівняння). Нестроге порівняння виконує перетворення типів, а строге порівняння перевіряє як значення, так і тип.

### Логічні оператори - Логічні операції

Уявіть собі, що ви приймаєте рішення на основі кількох умов. Логічні оператори допомагають об'єднувати умови та приймати рішення.

```javascript
&& || ! ?? (nullish coalescing)
```

`&&` (AND) - обидві умови мають бути істинними. `||` (OR) - хоча б одна умова має бути істинною. `!` (NOT) - інвертує значення. `??` (nullish coalescing) - повертає правий операнд, якщо лівий є `null` або `undefined`.

### Оператори присвоєння - Присвоєння з операцією

Уявіть собі, що ви не просто кладете предмет в коробку, а виконуєте дію з предметом перед тим, як покласти його в коробку.

```javascript
= += -= *= /= %= **= <<= >>= >>>= &= |= ^=
```

Ці оператори дозволяють виконувати операцію та присвоєння одночасно. Наприклад, `x += 5` еквівалентно `x = x + 5`.

### Тернарний оператор - Умовний оператор

Уявіть собі, що у вас є два шляхи, і ви вибираєте один з них залежно від умови. Тернарний оператор дозволяє робити це в одному рядку.

```javascript
const result = condition ? value1 : value2;
```

Якщо `condition` істинне, повертається `value1`, інакше - `value2`. Це компактний спосіб записати умовну логіку.

## 11. Array Methods - Методи для роботи з масивами

### Основні методи - Інструменти для обробки масивів

Уявіть собі, що у вас є конвеєр з предметами, і ви можете виконувати різні операції з цими предметами: перетворювати їх, фільтрувати, рахувати. Методи масивів - це інструменти для роботи з колекціями даних.

```javascript
const arr = [1, 2, 3, 4, 5];

// map - перетворює кожен елемент
const doubled = arr.map((x) => x * 2); // [2, 4, 6, 8, 10]

// filter - фільтрує елементи за умовою
const evens = arr.filter((x) => x % 2 === 0); // [2, 4]

// reduce - зводить масив до одного значення
const sum = arr.reduce((acc, curr) => acc + curr, 0); // 15

// find - знаходить перший елемент, що відповідає умові
const firstEven = arr.find((x) => x % 2 === 0); // 2

// some - перевіряє, чи хоча б один елемент відповідає умові
const hasEven = arr.some((x) => x % 2 === 0); // true

// every - перевіряє, чи всі елементи відповідають умові
const allPositive = arr.every((x) => x > 0); // true
```

Кожен метод має своє призначення. `map` - для перетворення, `filter` - для фільтрації, `reduce` - для зведення до одного значення, `find` - для пошуку, `some` та `every` - для перевірки умов.

### reduceRight - Обробка справа наліво

Уявіть собі, що ви читаєте книгу з кінця до початку. `reduceRight` працює так само - обробляє елементи масиву справа наліво.

```javascript
const arr = ["a", "b", "c"];

// Зліва направо
const leftToRight = arr.reduce((acc, curr) => acc + curr); // "abc"

// Справа наліво
const rightToLeft = arr.reduceRight((acc, curr) => acc + curr); // "cba"

// Практичний приклад
const numbers = [1, 2, 3, 4];
const result = numbers.reduceRight((acc, curr) => {
  return acc - curr;
}, 0); // 0 - 4 - 3 - 2 - 1 = -10
```

У цьому прикладі `reduceRight` починає з останнього елемента і рухається до першого. Це може бути корисно, коли порядок обробки має значення.

## 12. Лексична область видимості (Lexical Scope) - Область видимості за місцем оголошення

### Визначення - Область видимості визначається місцем оголошення

Уявіть собі, що ви знаходитесь в будинку з кількома кімнатами. Кожна кімната має свої речі, але ви також можете бачити речі з кімнат, які знаходяться "вище" по ієрархії. Це лексична область видимості.

Лексична область видимості означає, що область видимості змінної визначається місцем її оголошення в коді. Внутрішні функції мають доступ до змінних зовнішніх функцій, але не навпаки.

```javascript
const globalVar = "global";

function outer() {
  const outerVar = "outer";

  function inner() {
    const innerVar = "inner";
    console.log(globalVar); // "global"
    console.log(outerVar); // "outer"
    console.log(innerVar); // "inner"
  }

  inner();
}

outer();
```

У цьому прикладі функція `inner` має доступ до всіх змінних: `globalVar` (глобальна), `outerVar` (з функції `outer`) та `innerVar` (власна). Це як бути в кімнаті всередині кімнати - ви бачите все, що знаходиться "вище" по ієрархії.

## 13. Динамічна область видимості (Dynamic Scope) - Область видимості за місцем виклику

### Визначення - Область видимості визначається місцем виклику

Уявіть собі, що ви зателефонували другу і попросили його подивитися, що знаходиться в його кімнаті. Він бачить свої речі, а не ваші. Це динамічна область видимості - область видимості визначається місцем виклику функції, а не місцем її оголошення.

JavaScript використовує лексичну область видимості, але `this` - це найближчий приклад динамічної області видимості. Значення `this` залежить від того, як викликається функція.

```javascript
// JavaScript використовує лексичну область видимості
// this - найближчий приклад динамічної області видимості

const obj = {
  name: "Object",
  method: function () {
    console.log(this.name);
  },
};

obj.method(); // "Object"

const func = obj.method;
func(); // undefined (this втрачається)
```

У першому випадку `this` вказує на об'єкт `obj`, тому `this.name` дорівнює `"Object"`. У другому випадку функція викликається без контексту, тому `this` вказує на глобальний об'єкт, де `name` не визначено.

## 14. JSON - Формат обміну даними

### Робота з JSON - Перетворення об'єктів в текст і назад

Уявіть собі, що у вас є складний механізм, який потрібно відправити поштою. Ви розбираєте його на частини, упаковуєте з інструкцією, а потім одержувач збирає його назад. JSON працює так само - перетворює складні об'єкти в текст для передачі.

JSON (JavaScript Object Notation) - це формат обміну даними, який використовується для передачі об'єктів між різними системами. Він має простий синтаксис і легко читається як людьми, так і машинами.

```javascript
// Об'єкт в JSON
const obj = { name: "John", age: 30 };
const jsonString = JSON.stringify(obj);
console.log(jsonString); // '{"name":"John","age":30}'

// JSON в об'єкт
const parsedObj = JSON.parse(jsonString);
console.log(parsedObj.name); // "John"

// Форматування
const prettyJson = JSON.stringify(obj, null, 2);
console.log(prettyJson);
// {
//   "name": "John",
//   "age": 30
// }

// Реплейсер
const replacer = (key, value) => {
  if (key === "age") return undefined; // виключаємо age
  return value;
};
const filteredJson = JSON.stringify(obj, replacer);
console.log(filteredJson); // '{"name":"John"}'
```

`JSON.stringify()` перетворює об'єкт в JSON-рядок. Другий параметр `null` - це replacer (функція для фільтрації), третій параметр `2` - це кількість пробілів для відступів. `JSON.parse()` перетворює JSON-рядок назад в об'єкт.

## 15. Spread Operator - Розширення масивів та об'єктів

### Розширення масивів - Копіювання та об'єднання

Уявіть собі, що у вас є коробка з цукерками, і ви хочете пересипати їх в іншу коробку або змішати з цукерками з іншої коробки. Spread operator (`...`) дозволяє "розсипати" елементи масиву.

```javascript
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
const combined = [...arr1, ...arr2]; // [1, 2, 3, 4, 5, 6]

// Копіювання масиву
const copy = [...arr1]; // [1, 2, 3]

// Додавання елементів
const newArr = [0, ...arr1, 4]; // [0, 1, 2, 3, 4]
```

Spread operator створює поверхневу копію масиву. Це означає, що примітивні значення копіюються, а об'єкти копіюються за посиланням.

### Розширення об'єктів - Копіювання та об'єднання властивостей

Spread operator також працює з об'єктами, дозволяючи копіювати та об'єднувати властивості.

```javascript
const obj1 = { name: "John" };
const obj2 = { age: 30 };
const combined = { ...obj1, ...obj2 }; // { name: 'John', age: 30 }

// Копіювання об'єкта
const copy = { ...obj1 }; // { name: 'John' }

// Перезапис властивостей
const updated = { ...obj1, name: "Jane" }; // { name: 'Jane' }
```

При об'єднанні об'єктів властивості з наступних об'єктів перезаписують властивості з попередніх. Це корисно для створення нових об'єктів на основі існуючих.

### Функціональні аргументи - Передача аргументів

Spread operator також дозволяє передавати елементи масиву як окремі аргументи функції.

```javascript
function sum(...numbers) {
  return numbers.reduce((acc, curr) => acc + curr, 0);
}

console.log(sum(1, 2, 3, 4)); // 10

// Передача аргументів
const args = [1, 2, 3];
console.log(sum(...args)); // 6
```

У першому випадку rest operator (`...numbers`) збирає всі аргументи в масив. У другому випадку spread operator (`...args`) розширює масив в окремі аргументи.

## 16. Rest Operator - Збір залишкових параметрів

### Збір залишкових параметрів - Збір "зайвих" аргументів

Уявіть собі, що ви організовуєте вечірку і запрошуєте кількох друзів. Перші два гості - це особливі гості, а всі інші - звичайні гості. Rest operator дозволяє "збирати" всіх інших гостей в окрему групу.

Rest operator (`...`) збирає всі залишкові параметри в масив. Це корисно, коли ви не знаєте заздалегідь, скільки аргументів буде передано.

```javascript
function log(first, second, ...rest) {
  console.log(first); // 1
  console.log(second); // 2
  console.log(rest); // [3, 4, 5]
}

log(1, 2, 3, 4, 5);

// Деструктуризація
const [first, second, ...remaining] = [1, 2, 3, 4, 5];
console.log(first); // 1
console.log(second); // 2
console.log(remaining); // [3, 4, 5]

const { name, ...otherProps } = { name: "John", age: 30, city: "NY" };
console.log(name); // "John"
console.log(otherProps); // { age: 30, city: 'NY' }
```

Rest operator може використовуватися не тільки в параметрах функцій, але й при деструктуризації масивів та об'єктів. Це дозволяє легко розділяти дані на частини.

## 17. Callbacks - Функції як аргументи

### Синхронні колбеки - Функції, які виконуються одразу

Уявіть собі, що ви даєте інструкції роботу: "Візьми цей список чисел і помнож кожне на 2". Робот виконує вашу інструкцію одразу і повертає результат. Це синхронний колбек.

Синхронні колбеки виконуються одразу під час виконання функції. Вони корисні для обробки даних та перетворень.

```javascript
function processArray(arr, callback) {
  const result = [];
  for (let i = 0; i < arr.length; i++) {
    result.push(callback(arr[i]));
  }
  return result;
}

const numbers = [1, 2, 3, 4];
const doubled = processArray(numbers, (x) => x * 2);
console.log(doubled); // [2, 4, 6, 8]
```

У цьому прикладі функція `processArray` приймає масив та колбек-функцію. Для кожного елемента масиву викликається колбек, і результат додається до нового масиву.

### Асинхронні колбеки - Функції, які виконуються пізніше

Уявіть собі, що ви замовляєте їжу в ресторані і даєте офіціанту свій номер телефону: "Покликни мене, коли їжа буде готова". Офіціант виконує ваше замовлення, а потім викликає вас. Це асинхронний колбек.

Асинхронні колбеки виконуються після завершення асинхронної операції. Вони корисні для обробки результатів запитів до сервера, файлових операцій тощо.

```javascript
function fetchData(callback) {
  setTimeout(() => {
    const data = { id: 1, name: "John" };
    callback(null, data);
  }, 1000);
}

fetchData((error, data) => {
  if (error) {
    console.error("Error:", error);
  } else {
    console.log("Data:", data);
  }
});

// Callback Hell (проблема)
fetchData((error, user) => {
  if (error) return console.error(error);

  fetchUserPosts(user.id, (error, posts) => {
    if (error) return console.error(error);

    fetchPostComments(posts[0].id, (error, comments) => {
      if (error) return console.error(error);
      console.log(comments);
    });
  });
});
```

У першому прикладі `fetchData` симулює асинхронну операцію за допомогою `setTimeout`. Після завершення операції викликається колбек з результатом.

Другий приклад показує "Callback Hell" - проблему з вкладеними колбеками, яка робить код важким для читання та підтримки. Це одна з причин, чому були створені Promise та async/await.

## Додаткові теми

### 18. Деструктуризація - Розпакування даних

Уявіть собі, що у вас є подарунок, загорнутий в кілька шарів паперу. Щоб дістати до подарунка, ви розгортаєте кожен шар і витягуєте те, що всередині. Деструктуризація працює так само - вона дозволяє "розпакувати" дані з масивів та об'єктів.

Деструктуризація - це синтаксис, який дозволяє витягувати значення з масивів або властивостей з об'єктів і присвоювати їх змінним. Це робить код більш читабельним і зручним.

```javascript
// Масиви
const [a, b, c] = [1, 2, 3];
const [first, ...rest] = [1, 2, 3, 4, 5];

// Об'єкти
const { name, age } = { name: "John", age: 30 };
const { name: userName, age: userAge } = { name: "John", age: 30 };

// Вкладена деструктуризація
const {
  user: {
    name,
    address: { city },
  },
} = {
  user: { name: "John", address: { city: "NY" } },
};
```

У першому прикладі ми "розпаковуємо" масив, присвоюючи перші три елементи змінним `a`, `b`, `c`. У другому прикладі ми використовуємо rest operator, щоб зібрати всі інші елементи в масив `rest`.

При деструктуризації об'єктів ми можемо використовувати різні назви змінних (як `userName` замість `name`) та "занурюватися" в глибоко вкладені об'єкти.

### 19. Template Literals - Рядки з інтерполяцією

Уявіть собі, що ви пишете лист другу і хочете особисто звернутися до нього. Замість того, щоб писати "Дорогий [ім'я]", ви можете вставити його ім'я безпосередньо в текст. Template literals дозволяють робити це в JavaScript.

Template literals - це спосіб створення рядків, який дозволяє вставляти змінні та вирази безпосередньо в текст. Вони використовують зворотні лапки (`) замість звичайних лапок.

```javascript
const name = "John";
const greeting = `Hello, ${name}!`;
const multiline = `
    This is a
    multiline string
`;

// Tagged templates
function tag(strings, ...values) {
  return strings.reduce((result, str, i) => {
    return result + str + (values[i] || "");
  }, "");
}

const result = tag`Hello ${name}!`;
```

У першому прикладі `${name}` вставляє значення змінної `name` в рядок. У другому прикладі показано, як створювати багаторядкові рядки без необхідності використовувати `\n`.

Tagged templates - це розширена функціональність, яка дозволяє обробляти template literals через функцію. Це корисно для інтернаціоналізації, форматування тощо.

### 20. Modules (ES6) - Організація коду

Уявіть собі, що ви організовуєте велику бібліотеку. Замість того, щоб тримати всі книги в одній кімнаті, ви розділяєте їх по темах: наукова література, художня література, довідники. Modules в JavaScript працюють так само - вони дозволяють організовувати код по логічних частинах.

Modules - це спосіб організації коду, який дозволяє розділяти код на окремі файли та імпортувати/експортувати функціональність між ними. Це робить код більш організованим, підтримуваним та перевикористовуваним.

```javascript
// export.js
export const PI = 3.14;
export function add(a, b) {
  return a + b;
}
export default class Calculator {}

// import.js
import Calculator, { PI, add } from "./export.js";
import * as math from "./export.js";
```

У файлі `export.js` ми експортуємо константу `PI`, функцію `add` та клас `Calculator` як default export. У файлі `import.js` ми імпортуємо ці елементи та можемо використовувати їх.

`export default` означає, що цей елемент є основним експортом модуля. При імпорті його можна називати будь-яким ім'ям. `import * as math` імпортує всі експорти в об'єкт `math`.

### 21. Generators - Функції, які можна зупиняти

Уявіть собі, що ви читаєте книгу і можете зупинитися в будь-який момент, зробити щось інше, а потім повернутися і продовжити читання з того місця, де зупинилися. Generators працюють так само - це функції, які можна зупиняти та відновлювати.

Generators - це спеціальний тип функцій, які можуть призупиняти своє виконання та відновлювати його пізніше. Вони використовують ключове слово `function*` та `yield`.

```javascript
function* numberGenerator() {
  yield 1;
  yield 2;
  yield 3;
}

const gen = numberGenerator();
console.log(gen.next().value); // 1
console.log(gen.next().value); // 2
console.log(gen.next().value); // 3
```

Ключове слово `yield` призупиняє виконання функції та повертає значення. При наступному виклику `next()` функція продовжує виконання з того місця, де зупинилася.

Generators корисні для створення ітераторів, обробки великих наборів даних, асинхронного програмування тощо.

### 22. Proxy - Перехоплення операцій з об'єктами

Уявіть собі, що у вас є секретар, який перехоплює всі ваші телефонні дзвінки, записи на зустрічі та повідомлення. Секретар може обробляти ці запити, додавати додаткову інформацію або навіть змінювати їх. Proxy в JavaScript працює так само - він дозволяє перехоплювати операції з об'єктами.

Proxy - це об'єкт, який обгортає інший об'єкт і перехоплює операції з ним (читання властивостей, запис, видалення тощо). Це дозволяє додавати додаткову логіку без зміни оригінального об'єкта.

```javascript
const target = { name: "John" };
const handler = {
  get(target, prop) {
    console.log(`Accessing property: ${prop}`);
    return target[prop];
  },
};

const proxy = new Proxy(target, handler);
console.log(proxy.name); // "Accessing property: name" + "John"
```

У цьому прикладі ми створюємо Proxy, який логує всі спроби доступу до властивостей об'єкта. Коли ми звертаємося до `proxy.name`, спрацьовує handler `get`, який виводить повідомлення та повертає значення.

Proxy корисні для валідації, логування, кешування, обсервери тощо.

### 23. WeakMap/WeakSet - Слабкі колекції

Уявіть собі, що у вас є спеціальна система зберігання, де предмети автоматично видаляються, коли вони більше не потрібні. WeakMap та WeakSet працюють так само - вони автоматично очищаються, коли об'єкти, які вони містять, більше не використовуються.

WeakMap та WeakSet - це колекції, які зберігають "слабкі" посилання на об'єкти. Це означає, що якщо об'єкт більше не використовується в інших місцях, він автоматично видаляється з колекції.

```javascript
const weakMap = new WeakMap();
const obj = {};

weakMap.set(obj, "value");
console.log(weakMap.get(obj)); // "value"

// Автоматично очищається при видаленні об'єкта
obj = null; // weakMap тепер порожній
```

У цьому прикладі ми створюємо WeakMap та додаємо в неї об'єкт зі значенням. Коли ми присвоюємо `obj = null`, об'єкт більше не використовується, тому він автоматично видаляється з WeakMap.

WeakMap та WeakSet корисні для кешування, зберігання метаданих, уникнення витоків пам'яті тощо.

### 24. Optional Chaining - Безпечний доступ до властивостей

Уявіть собі, що ви шукаєте адресу в складній системі папок. Замість того, щоб перевіряти кожну папку на існування, ви можете просто "зануритися" в структуру, і якщо якась папка не існує, ви просто отримаєте `undefined` замість помилки. Optional chaining працює так само.

Optional chaining (`?.`) - це оператор, який дозволяє безпечно отримувати доступ до властивостей об'єктів, навіть якщо проміжні властивості можуть бути `null` або `undefined`.

```javascript
const user = {
  address: {
    street: "Main St",
  },
};

// Безопасний доступ до властивостей
console.log(user?.address?.street); // "Main St"
console.log(user?.contact?.phone); // undefined

// З nullish coalescing
console.log(user?.contact?.phone ?? "No phone"); // "No phone"
```

У першому прикладі ми безпечно отримуємо доступ до `street` через `address`. У другому прикладі `contact` не існує, тому повертається `undefined` замість помилки.

Nullish coalescing (`??`) повертає правий операнд, якщо лівий є `null` або `undefined`. Це корисно для встановлення значень за замовчуванням.

### 25. Logical Assignment Operators - Логічні оператори присвоєння

Уявіть собі, що у вас є система автоматизації, яка виконує дії тільки за певних умов. Наприклад, автоматично заповнює порожні поля або оновлює значення тільки якщо вони відсутні. Logical assignment operators працюють так само.

Logical assignment operators - це скорочений спосіб виконання логічних операцій з присвоєнням. Вони дозволяють виконувати операцію та присвоєння одночасно, але тільки за певних умов.

```javascript
let x = 1;
let y = 2;

// Logical AND assignment
x &&= y; // x = x && y
console.log(x); // 2

// Logical OR assignment
x ||= 0; // x = x || 0

// Nullish coalescing assignment
x ??= 0; // x = x ?? 0
```

`&&=` присвоює значення тільки якщо лівий операнд є істинним. `||=` присвоює значення тільки якщо лівий операнд є хибним. `??=` присвоює значення тільки якщо лівий операнд є `null` або `undefined`.

Ці оператори корисні для встановлення значень за замовчуванням, умовного оновлення змінних тощо.

### 26. Map та Set - Спеціалізовані колекції

Map та Set - це нові типи колекцій, введені в ES6, які надають більш спеціалізовану функціональність порівняно з об'єктами та масивами.

Map - це колекція ключ-значення, де ключі можуть бути будь-якого типу (не тільки рядки, як в об'єктах). Set - це колекція унікальних значень.

```javascript
// Map - колекція ключ-значення
const userMap = new Map();

userMap.set(1, "John");
userMap.set("email", "john@example.com");
userMap.set({ id: 1 }, "User object");

console.log(userMap.get(1)); // "John"
console.log(userMap.has("email")); // true
console.log(userMap.size); // 3

// Set - колекція унікальних значень
const uniqueNumbers = new Set([1, 2, 2, 3, 3, 4]);
console.log([...uniqueNumbers]); // [1, 2, 3, 4]

const uniqueUsers = new Set();
uniqueUsers.add({ name: "John" });
uniqueUsers.add({ name: "John" }); // Додасться, бо це різні об'єкти
```

Map надає методи `set()`, `get()`, `has()`, `delete()`, `clear()` та властивість `size`. Set надає методи `add()`, `has()`, `delete()`, `clear()` та властивість `size`.

### 27. Генератори (Generators) - Функції з пам'яттю стану

Генератори - це спеціальний тип функцій, які можуть призупиняти своє виконання та відновлювати його пізніше. Вони використовують ключове слово `function*` та `yield`.

Генератори корисні для створення ітераторів, обробки великих наборів даних та асинхронного програмування.

```javascript
// Простий генератор
function* numberGenerator() {
  yield 1;
  yield 2;
  yield 3;
}

const gen = numberGenerator();
console.log(gen.next().value); // 1
console.log(gen.next().value); // 2
console.log(gen.next().value); // 3
console.log(gen.next().done); // true

// Генератор з параметрами
function* fibonacci() {
  let [prev, curr] = [0, 1];
  while (true) {
    yield curr;
    [prev, curr] = [curr, prev + curr];
  }
}

const fib = fibonacci();
console.log(fib.next().value); // 1
console.log(fib.next().value); // 1
console.log(fib.next().value); // 2
console.log(fib.next().value); // 3
```

Ключове слово `yield` призупиняє виконання функції та повертає значення. При наступному виклику `next()` функція продовжує виконання з того місця, де зупинилася.

### 28. Proxy - Перехоплення операцій з об'єктами

Proxy - це об'єкт, який обгортає інший об'єкт і перехоплює операції з ним (читання властивостей, запис, видалення тощо). Це дозволяє додавати додаткову логіку без зміни оригінального об'єкта.

```javascript
const target = { name: "John", age: 30 };

const handler = {
  get(target, prop) {
    console.log(`Accessing property: ${prop}`);
    return target[prop];
  },

  set(target, prop, value) {
    console.log(`Setting property: ${prop} = ${value}`);
    target[prop] = value;
    return true;
  },

  deleteProperty(target, prop) {
    console.log(`Deleting property: ${prop}`);
    delete target[prop];
    return true;
  },
};

const proxy = new Proxy(target, handler);

console.log(proxy.name); // "Accessing property: name" + "John"
proxy.age = 31; // "Setting property: age = 31"
delete proxy.name; // "Deleting property: name"
```

Proxy корисні для валідації, логування, кешування, обсервери та інших патернів, де потрібно перехоплювати операції з об'єктами.

### 29. Reflect - Утиліти для роботи з об'єктами

Reflect - це вбудований об'єкт, який надає методи для перехоплювання JavaScript операцій. Ці методи відповідають операціям, які можна перехопити через Proxy.

```javascript
const obj = { name: "John", age: 30 };

// Reflect.get - отримання властивості
console.log(Reflect.get(obj, "name")); // "John"

// Reflect.set - встановлення властивості
Reflect.set(obj, "age", 31);
console.log(obj.age); // 31

// Reflect.has - перевірка наявності властивості
console.log(Reflect.has(obj, "name")); // true

// Reflect.deleteProperty - видалення властивості
Reflect.deleteProperty(obj, "age");
console.log(obj.hasOwnProperty("age")); // false

// Reflect.construct - створення об'єкта через конструктор
function Person(name) {
  this.name = name;
}
const person = Reflect.construct(Person, ["John"]);
console.log(person.name); // "John"
```

Reflect надає більш функціональний підхід до роботи з об'єктами порівняно з традиційними операторами.

### 30. WeakMap та WeakSet - Слабкі колекції

WeakMap та WeakSet - це колекції, які зберігають "слабкі" посилання на об'єкти. Це означає, що якщо об'єкт більше не використовується в інших місцях, він автоматично видаляється з колекції.

```javascript
const weakMap = new WeakMap();
const weakSet = new WeakSet();

let obj1 = { name: "John" };
let obj2 = { name: "Jane" };

// Додавання об'єктів
weakMap.set(obj1, "Data for John");
weakSet.add(obj1);

console.log(weakMap.get(obj1)); // "Data for John"
console.log(weakSet.has(obj1)); // true

// Видалення посилання на об'єкт
obj1 = null;

// Об'єкт автоматично видаляється з WeakMap та WeakSet
// weakMap.get(obj1) та weakSet.has(obj1) повернуть undefined/false
```

WeakMap та WeakSet корисні для кешування, зберігання метаданих та уникнення витоків пам'яті. Вони не підтримують ітерацію та не мають властивості `size`.

### 31. Symbol - Унікальні ідентифікатори

Symbol - це примітивний тип в JavaScript, який створює унікальні ідентифікатори. Кожен символ є абсолютно унікальним, навіть якщо має однаковий опис. Це робить символи ідеальними для створення приватних властивостей об'єктів та уникнення конфліктів імен.

Символи використовуються в багатьох вбудованих JavaScript API, таких як ітератори, метадані та внутрішні властивості об'єктів. Вони забезпечують безпечний спосіб додавання властивостей до об'єктів без ризику перезапису існуючих властивостей.

Глобальні символи дозволяють створювати символи, які можна розділяти між різними частинами коду, використовуючи Symbol.for() та Symbol.keyFor().

```javascript
// Створення символів
const sym1 = Symbol("description");
const sym2 = Symbol("description");
console.log(sym1 === sym2); // false (символи завжди унікальні)

// Глобальні символи
const globalSym = Symbol.for("global");
const sameGlobalSym = Symbol.for("global");
console.log(globalSym === sameGlobalSym); // true

// Використання символів як ключів об'єктів
const obj = {
  [Symbol("private")]: "This is private",
  public: "This is public",
};

console.log(Object.keys(obj)); // ["public"] (символи не з'являються)
console.log(Object.getOwnPropertySymbols(obj)); // [Symbol(private)]
```

Символи корисні для створення "приватних" властивостей, уникнення конфліктів імен та створення метаданих.

### 32. BigInt - Робота з великими числами

BigInt - це примітивний тип в JavaScript, який дозволяє працювати з цілими числами довільної точності. Це рішення для обмежень стандартного типу Number, який може точно представляти числа тільки до 2^53 - 1.

BigInt числа створюються додаванням суфікса `n` до кінця числа або використанням конструктора `BigInt()`. Вони підтримують всі стандартні арифметичні операції, але не можуть змішуватися зі звичайними числами без явного перетворення.

BigInt особливо корисні в фінансових розрахунках, криптографії, наукових обчисленнях та інших сферах, де потрібна висока точність при роботі з великими числами.

```javascript
// Створення BigInt
const bigInt1 = 9007199254740991n;
const bigInt2 = BigInt("9007199254740991");

// Арифметичні операції
console.log(bigInt1 + 1n); // 9007199254740992n
console.log(bigInt1 * 2n); // 18014398509481982n

// Порівняння
console.log(1n < 2n); // true
console.log(1n == 1); // true (нестроге порівняння)
console.log(1n === 1); // false (строге порівняння)

// Конвертація
console.log(Number(bigInt1)); // 9007199254740991
console.log(BigInt(123)); // 123n
```

BigInt корисні для роботи з великими числами, криптографії, фінансових розрахунків та інших сфер, де потрібна висока точність.

### 33. Optional Chaining - Безпечний доступ до властивостей

Optional chaining (`?.`) - це оператор, який дозволяє безпечно отримувати доступ до властивостей об'єктів, навіть якщо проміжні властивості можуть бути `null` або `undefined`. Це елегантний спосіб уникнути помилок при роботі з глибоко вкладеними об'єктами.

Оператор автоматично перевіряє кожну властивість в ланцюжку та повертає `undefined`, якщо будь-яка проміжна властивість є `null` або `undefined`. Це значно спрощує код, який раніше потребував множинних перевірок.

Optional chaining працює не тільки з властивостями об'єктів, але й з викликами функцій та доступом до елементів масивів, що робить його універсальним інструментом для безпечної роботи з даними.

```javascript
const user = {
  profile: {
    address: {
      street: "Main St",
    },
  },
};

// Безпечний доступ
console.log(user?.profile?.address?.street); // "Main St"
console.log(user?.profile?.contact?.phone); // undefined

// З функціями
const obj = {
  method: () => "Hello",
};

console.log(obj?.method?.()); // "Hello"
console.log(obj?.nonExistentMethod?.()); // undefined

// З масивами
const arr = [1, 2, 3];
console.log(arr?.[0]); // 1
console.log(arr?.[10]); // undefined
```

Optional chaining дозволяє уникнути помилок при доступі до властивостей, які можуть не існувати.

### 34. Nullish Coalescing - Оператор нульового злиття

Nullish coalescing (`??`) - це оператор, який повертає правий операнд, якщо лівий є `null` або `undefined`. Це відрізняється від логічного OR (`||`), який повертає правий операнд для будь-яких "falsy" значень, включаючи `0`, `""`, `false`.

Оператор `??` дозволяє точно розрізняти між "відсутністю значення" (`null`/`undefined`) та "валідними falsy значеннями" (`0`, `""`, `false`). Це критично важливо в багатьох сценаріях, де `0` або порожній рядок є валідними значеннями.

Nullish coalescing особливо корисний при встановленні значень за замовчуванням, роботі з API, які можуть повертати `null`, та в будь-яких ситуаціях, де потрібно розрізняти відсутність даних від валідних "порожніх" значень.

```javascript
// Порівняння з ||
console.log(0 || "default"); // "default"
console.log(0 ?? "default"); // 0

console.log("" || "default"); // "default"
console.log("" ?? "default"); // ""

console.log(false || "default"); // "default"
console.log(false ?? "default"); // false

console.log(null || "default"); // "default"
console.log(null ?? "default"); // "default"

console.log(undefined || "default"); // "default"
console.log(undefined ?? "default"); // "default"

// Практичний приклад
function createUser(name, age) {
  return {
    name: name ?? "Anonymous",
    age: age ?? 18,
  };
}

console.log(createUser("John", 0)); // { name: "John", age: 0 }
console.log(createUser(null, null)); // { name: "Anonymous", age: 18 }
```

Nullish coalescing корисний для встановлення значень за замовчуванням, коли потрібно розрізняти `null`/`undefined` від інших "falsy" значень.

### 35. Logical Assignment Operators - Логічні оператори присвоєння

Logical assignment operators - це скорочений спосіб виконання логічних операцій з присвоєнням. Вони дозволяють виконувати операцію та присвоєння одночасно, але тільки за певних умов, що робить код більш читабельним та ефективним.

Ці оператори поєднують логічні операції (`&&`, `||`, `??`) з присвоєнням, виконуючи присвоєння тільки коли логічна умова виконується. Це дозволяє уникнути повторного написання змінної та робить код більш лаконічним.

Logical assignment operators особливо корисні для встановлення значень за замовчуванням, умовного оновлення змінних та спрощення умовної логіки в коді.

```javascript
let x = 1;
let y = 2;

// Logical AND assignment (&&=)
x &&= y; // Еквівалентно: x = x && y
console.log(x); // 2

// Logical OR assignment (||=)
let z = 0;
z ||= 10; // Еквівалентно: z = z || 10
console.log(z); // 10

// Nullish coalescing assignment (??=)
let w = null;
w ??= 20; // Еквівалентно: w = w ?? 20
console.log(w); // 20

// Практичні приклади
const config = {};

// Встановлення значень за замовчуванням
config.port ||= 3000;
config.host ||= "localhost";
config.debug ??= false;

console.log(config); // { port: 3000, host: "localhost", debug: false }
```

Ці оператори корисні для встановлення значень за замовчуванням та умовного оновлення змінних.

### 36. Template Literals - Розширені можливості рядків

Template literals - це сучасний спосіб створення рядків в JavaScript, який дозволяє вставляти змінні та вирази безпосередньо в текст. Вони використовують зворотні лапки (`) замість звичайних лапок та підтримують інтерполяцію через `${}`.

Template literals надають значно більше можливостей порівняно з традиційними рядками. Вони підтримують багаторядковість без необхідності використання символів нового рядка, інтерполяцію змінних та виразів, а також tagged templates для кастомної обробки рядків.

Tagged templates дозволяють створювати функції, які обробляють template literals, що відкриває можливості для створення DSL (Domain Specific Languages), інтернаціоналізації, HTML-шаблонів та інших складних сценаріїв роботи з рядками.

```javascript
const name = "John";
const age = 30;

// Базова інтерполяція
const greeting = `Hello, ${name}! You are ${age} years old.`;
console.log(greeting); // "Hello, John! You are 30 years old."

// Багаторядкові рядки
const multiline = `
  This is a
  multiline string
  with proper formatting
`;

// Вирази в template literals
const price = 10;
const quantity = 3;
const total = `Total: $${price * quantity}`;
console.log(total); // "Total: $30"

// Tagged templates
function tag(strings, ...values) {
  return strings.reduce((result, str, i) => {
    return result + str + (values[i] || "");
  }, "");
}

const result = tag`Hello ${name}!`;
console.log(result); // "Hello John!"
```

Template literals роблять код більш читабельним та зручним для роботи з рядками.

### 37. Modules (ES6) - Система модулів

ES6 модулі - це стандартний спосіб організації коду в JavaScript, який дозволяє розділяти код на окремі файли та імпортувати/експортувати функціональність між ними. Це фундаментальна концепція сучасної JavaScript розробки.

Модулі забезпечують інкапсуляцію коду, дозволяючи контролювати, які частини коду доступні ззовні. Вони також підтримують статичний аналіз залежностей, що дозволяє інструментам збірки оптимізувати завантаження та виявляти помилки на етапі компіляції.

Система модулів підтримує як named exports (іменовані експорти), так і default exports (експорти за замовчуванням), що забезпечує гнучкість при організації коду. Модулі також підтримують реекспорт та динамічний імпорт для складних сценаріїв завантаження.

```javascript
// math.js - модуль з математичними функціями
export const PI = 3.14159;

export function add(a, b) {
  return a + b;
}

export function multiply(a, b) {
  return a * b;
}

// Default export
export default class Calculator {
  constructor() {
    this.result = 0;
  }

  add(value) {
    this.result += value;
    return this;
  }

  getResult() {
    return this.result;
  }
}

// main.js - використання модуля
import Calculator, { PI, add, multiply } from "./math.js";

console.log(PI); // 3.14159
console.log(add(2, 3)); // 5
console.log(multiply(4, 5)); // 20

const calc = new Calculator();
calc.add(10).add(20);
console.log(calc.getResult()); // 30

// Імпорт всього модуля
import * as math from "./math.js";
console.log(math.PI); // 3.14159
```

Модулі забезпечують інкапсуляцію, перевикористання коду та кращу організацію проекту.

### 38. Деструктуризація - Розпакування даних

Деструктуризація - це синтаксис в JavaScript, який дозволяє витягувати значення з масивів або властивості з об'єктів і присвоювати їх змінним. Це потужний інструмент для спрощення роботи з даними та зменшення кількості повторюваного коду.

Деструктуризація працює як "розпакування" структурованих даних, дозволяючи отримати доступ до окремих елементів одним виразом. Вона підтримує значення за замовчуванням, перейменування змінних, пропуск елементів та вкладену деструктуризацію.

Цей синтаксис особливо корисний при роботі з функціями, які повертають об'єкти або масиви, при обробці параметрів функцій, а також при роботі з API, які повертають структуровані дані.

```javascript
// Деструктуризація масивів
const numbers = [1, 2, 3, 4, 5];
const [first, second, ...rest] = numbers;
console.log(first); // 1
console.log(second); // 2
console.log(rest); // [3, 4, 5]

// Деструктуризація об'єктів
const person = {
  name: "John",
  age: 30,
  city: "New York",
};

const { name, age, country = "USA" } = person;
console.log(name); // "John"
console.log(age); // 30
console.log(country); // "USA" (значення за замовчуванням)

// Перейменування властивостей
const { name: userName, age: userAge } = person;
console.log(userName); // "John"
console.log(userAge); // 30

// Вкладена деструктуризація
const user = {
  profile: {
    name: "John",
    address: {
      city: "New York",
      country: "USA",
    },
  },
};

const {
  profile: {
    name: userName,
    address: { city, country },
  },
} = user;

console.log(userName); // "John"
console.log(city); // "New York"
console.log(country); // "USA"
```

Деструктуризація робить код більш читабельним та зручним для роботи з даними.

### 39. Rest та Spread оператори - Робота з колекціями

Rest та Spread оператори використовують однаковий синтаксис (`...`), але мають різне призначення та контекст використання. Це два потужних інструменти для роботи з колекціями даних в JavaScript.

Spread оператор "розгортає" колекції, дозволяючи використовувати їх елементи в контексті, де очікуються окремі значення. Він корисний для копіювання масивів та об'єктів, об'єднання колекцій та передачі аргументів у функції.

Rest оператор "збирає" залишкові елементи в колекцію, дозволяючи працювати з невизначеною кількістю аргументів або елементів. Він особливо корисний при створенні функцій з варіативною кількістю параметрів та деструктуризації.

```javascript
// Spread оператор - розширення колекцій
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
const combined = [...arr1, ...arr2];
console.log(combined); // [1, 2, 3, 4, 5, 6]

// Копіювання масивів
const copy = [...arr1];
console.log(copy); // [1, 2, 3]

// Spread з об'єктами
const obj1 = { name: "John" };
const obj2 = { age: 30 };
const merged = { ...obj1, ...obj2 };
console.log(merged); // { name: "John", age: 30 }

// Rest оператор - збір залишкових елементів
function sum(...numbers) {
  return numbers.reduce((acc, curr) => acc + curr, 0);
}

console.log(sum(1, 2, 3, 4, 5)); // 15

// Rest в деструктуризації
const [first, second, ...remaining] = [1, 2, 3, 4, 5];
console.log(first); // 1
console.log(second); // 2
console.log(remaining); // [3, 4, 5]

// Rest з об'єктами
const { name, ...otherProps } = { name: "John", age: 30, city: "NY" };
console.log(name); // "John"
console.log(otherProps); // { age: 30, city: "NY" }
```

Spread оператор корисний для копіювання та об'єднання колекцій, а Rest оператор - для збору залишкових елементів.

### 40. Ітератори та ітерабельні об'єкти

Ітератори - це об'єкти, які надають стандартний спосіб перебору елементів через протокол ітерації. Вони забезпечують уніфікований інтерфейс для роботи з різними типами колекцій в JavaScript.

Ітерабельні об'єкти - це об'єкти, які можна перебирати за допомогою циклів `for...of` та інших конструкцій, що підтримують ітерацію. Вони реалізують метод `[Symbol.iterator]()`, який повертає ітератор.

Протокол ітерації дозволяє створювати власні ітерабельні об'єкти та ітератори, що відкриває можливості для створення кастомних колекцій та ленивих обчислень. Генератори також реалізують протокол ітерації, що робить їх потужним інструментом для створення ітераторів.

```javascript
// Створення ітератора
const iterable = {
  [Symbol.iterator]() {
    let step = 0;
    const iterator = {
      next() {
        step++;
        if (step === 1) {
          return { value: "Hello", done: false };
        } else if (step === 2) {
          return { value: "World", done: false };
        }
        return { done: true };
      },
    };
    return iterator;
  },
};

// Використання ітератора
for (const value of iterable) {
  console.log(value); // "Hello", "World"
}

// Генератор як ітератор
function* numberGenerator() {
  yield 1;
  yield 2;
  yield 3;
}

for (const num of numberGenerator()) {
  console.log(num); // 1, 2, 3
}

// Вбудовані ітерабельні об'єкти
const array = [1, 2, 3];
const string = "Hello";
const map = new Map([
  ["a", 1],
  ["b", 2],
]);

for (const item of array) {
  console.log(item); // 1, 2, 3
}

for (const char of string) {
  console.log(char); // "H", "e", "l", "l", "o"
}

for (const [key, value] of map) {
  console.log(`${key}: ${value}`); // "a: 1", "b: 2"
}
```

Ітератори забезпечують уніфікований спосіб роботи з різними типами колекцій в JavaScript.
